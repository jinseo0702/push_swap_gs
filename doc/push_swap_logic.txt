이 프로젝트는 제한된 명령어 세트를 사용하여 스택에 있는 데이터를 정렬하는 작업을 수행합니다.
가장 적은 수의 동작을 사용하여 최적화된 데이터 정렬을 위해 다양한 종류의 알고리즘을 조작하고
가장 적합한 솔루션을 선택해야 합니다.
* 문제가 원하는 방향
1. 스택으로 데이터를 받고 데이터를 정렬한다.
2. 가장 적은 수의 동작을 사용하여 최적화된 데이터 정렬을 위해 다양한 종류의 알고리즘을 조작한다.
3. 가장 적합한 솔루션을 선택해라 (? 이건 알고리즘을 선택하라는 건가?)

-->여기서 생각 해 봐야 하는점
적합한 솔루션이란?
1. 스택 구현 방법 (다양한 방법이 있다고 알고 있음)
2. 정렬하는 방법을 선택(알고리즘을 선택한다?)


푸쉬 스왑 프로젝트는 매우 간단하고 직관적인 알고리즘 프로젝트입니다: 
데이터를 정렬해야 합니다. 
여러분은 정수 값 세트, 2개의 스택, 그리고 스택을 조작하기 위한 일련의 명령어를 사용할 수 있습니다. 
여러분의 목표는 무엇일까요? 
입력으로 받은 정수를 정렬하는 가장 작은 프로그램을 작성하고 표준 출력에 표시하는 것입니다. 
쉽죠? 한번 보겠습니다...

-->여기서 생각 해 봐야 하는점
1. 데이터를 정렬한다.
2. 문제가 원하는 행동
    a. 정수값을 받을 스택 구현
    b. 데이터를 정렬하기 위한 몇몇의 명령어 사용
3. 우리의 목표
    a. 입력받은 정수를 정렬하는 가장적은 행동을 하는 프로그램을 작성후 표준 출력에 표시
    --> 이부분이 이해가 잘 안된다.

목표
encounter
정렬 알고리즘을 작성하는 것은 개발자 여정에서 매우 중요한 단계입니다. 
이는 종종 복잡성 개념과의 첫 만남입니다. 
정렬 알고리즘과 그들의 복잡성은 채용 인터뷰 중에 논의되는 고전적인 질문 중 하나입니다. 
아마도 언젠가는 이러한 개념에 직면하게 될 것이기 때문에 이러한 개념들을 살펴보는 것이 좋은 시기일 것입니다.
이 프로젝트의 학습 목표는 엄격함, C 언어 사용 및 기본 알고리즘 사용입니다. 
특히 그들의 복잡성에 중점을 두고 있습니다. 값들을 정렬하는 것은 간단합니다. 
그러나 가능한 한 빠르게 정렬하는 것은 덜 간단합니다. 
특히 하나의 정수 구성에서 다른 정수 구성으로 이동할 때 가장 효율적인 정렬 솔루션이 달라질 수 있기 때문입니다.

-->여기서 생각 해 봐야 하는점
1. 알고리즘은 회사 면접에서 자주 물어보는 질문중 하나 이며, 중요한 비중을 가지고 있다.
2. 정렬알고리즘을 생각하는 건 매우 쉽다. 하지만 최적화 하는것은 매우 어렵다.
--> 특정 상황에서 내가 선택한 알고리즘이 느려질 가능성이 있기 때문이다.

Mandatory part
1. 규칙
• a와 b 두 개의 스택이 있습니다.
• 처음에:
◦ 스택 a에는 중복되지 않는 임의의 음수 및/또는 양수 숫자가 포함되어 있습니다.
◦ 스택 b는 비어 있습니다.
• 목표는 스택 a의 숫자를 오름차순으로 정렬하는 것입니다. 이를 위해 다음과 같은 작업을 수행할 수 있습니다:
sa (a 스택 스왑): 스택 a의 맨 위에 있는 첫 번째 2개의 요소를 교환합니다.
요소가 하나만 있거나 없으면 아무 것도 하지 않습니다.
sb (b 스택 스왑): 스택 b의 맨 위에 있는 첫 번째 2개의 요소를 교환합니다.
요소가 하나만 있거나 없으면 아무 것도 하지 않습니다.
ss : 동시에 sa와 sb를 실행합니다.
pa (a로 푸시): 스택 b의 맨 위의 요소를 가져와 스택 a의 맨 위에 넣습니다.
b가 비어 있으면 아무 것도 하지 않습니다.
pb (b로 푸시): 스택 a의 맨 위의 요소를 가져와 스택 b의 맨 위에 넣습니다.
a가 비어 있으면 아무 것도 하지 않습니다.
ra (a 회전): 스택 a의 모든 요소를 위로 1개씩 이동합니다.
첫 번째 요소가 마지막이 됩니다.
rb (b 회전): 스택 b의 모든 요소를 위로 1개씩 이동합니다.
첫 번째 요소가 마지막이 됩니다.
rr : 동시에 ra와 rb를 실행합니다.
rra (a 역회전): 스택 a의 모든 요소를 아래로 1개씩 이동합니다.
마지막 요소가 첫 번째가 됩니다.
rrb (b 역회전): 스택 b의 모든 요소를 아래로 1개씩 이동합니다.
마지막 요소가 첫 번째가 됩니다.
rrr : 동시에 rra와 rrb를 실행합니다.

-->여기서 생각 해 봐야 하는점
1. 이러한 규칙들이 있는데 이 규칙들은 스택의 맨위에서 이루어 진다.--
--그렇다면 과연 정렬알고리즘과 이규칙들의 연관지어서 최적화할 수 있는 것인가?
2. 예를 들어서 버블 정렬을 사용 한다고 한다면 이 버블 정렬은 저장공간을 처음부터 끝까지 돌면서--
--사용된다. 그렇다면 저규칙에 맞게 사용을 한다면 어떻게 변경을 해야지 규칙에 맞게 알고리즘을 변형할 수 있는 것일까
3. 그렇다면 정렬 하는데 최소화 하는 공식은 어떻게 구해야 하는걸까?????????????????
    a. 정렬의 최소화공식을 한번 생각해보자
    b. 내가 생각 해야하는건 스택의 머리에서 정렬을 할 수있다는 점을 상기하자
    c. 문제가 예시로 준것보다 내가 정렬을 더 잘할 수 있을까?

2. The "push_swap" program
Program name : push_swap
Turn in files : Makefile, *.h, *.c
Makefile : NAME, all, clean, fclean, re
Arguments : stack a: A list of integers
External functs : read, write, malloc, free, exit, ft_printf and any equivalent YOU coded
libft authorized : Yes
Description : Sort stacks

프로젝트는 다음 규칙을 준수해야 합니다:
• 소스 파일을 컴파일하는 Makefile을 제출해야 합니다. 다시 링크해서는 안 됩니다.
• 전역 변수는 금지되어 있습니다.
• 정수 목록 형식으로 포맷된 스택 a를 인수로 취하는 push_swap이라는 프로그램을 작성해야 합니다. 첫 번째 인수는 스택의 맨 위에 있어야 합니다 (순서에 주의하세요).
• 프로그램은 스택 a를 정렬하는 데 가능한 한 작은 명령어 목록을 표시해야 합니다. 가장 작은 숫자가 맨 위에 있어야 합니다.
• 명령어는 '\n'으로 구분되어야 하며, 그 외에는 아무 것도 없어야 합니다.
• 목표는 가능한 한 적은 수의 작업으로 스택을 정렬하는 것입니다. 평가 과정에서는 프로그램이 찾은 명령어 수가 한도와 비교될 것입니다: 허용되는 작업의 최대 수입니다. 프로그램이 더 긴 목록을 표시하거나 숫자가 올바르게 정렬되지 않으면 등급은 0이 됩니다.
• 매개변수가 지정되지 않은 경우 프로그램은 아무것도 표시하지 않고 프롬프트를 반환해야 합니다.
• 오류가 발생하는 경우 표준 오류에 "Error" 다음에 '\n'을 표시해야 합니다. 오류에는 예를 들어 다음과 같은 것들이 포함됩니다: 일부 인수가 정수가 아니거나 일부 인수가 정수보다 크거나/또는 중복이 있습니다.
• 평가 과정에서 프로그램 검사기가 "KO"를 표시하면 push_swap이 숫자를 정렬하지 않는 명령어 목록을 생성한 것입니다.
• checker_OS 프로그램은 프로젝트 인트라넷의 리소스에서 제공됩니다.
• Bonus 파트에 그 작동 방법에 대한 설명을 찾을 수 있습니다.

Benchmark
이 프로젝트를 검증하려면 최소한의 작업으로 특정한 정렬을 수행해야 합니다:
• 최소한의 유효성 검사를 위해서는 (최소 80의 학점을 받아야 함), 100개의 무작위 숫자를 700회 이하의 작업으로 정렬할 수 있어야 합니다.
• 최대 프로젝트 유효성 검사를 위해서는 위의 첫 번째 단계를 수행해야 하지만, 또한 500개의 무작위 숫자를 사용하여 5500회 이상의 작업을 수행해서는 안 됩니다. 
이 모든 것은 평가 중에 확인될 것입니다.
• 보너스 부분을 완료하려면 각 벤치마크 단계에서 가능한 최고 점수를 달성하여 프로젝트를 철저하게 유효성 검사해야 합니다.



Bonus part
이 프로젝트는 간단함으로 인해 추가 기능을 추가할 여지가 거의 없습니다. 
그러나, 자체적인 검사 도구를 만들어보는 건 어떨까요?
information
체커 프로그램 덕분에 push_swap 프로그램이 생성한 명령어 목록이 스택을 올바르게 정렬하는지 확인할 수 있습니다.
warning
보너스 부분은 필수 부분이 완벽하게 완료되었을 때만 평가됩니다. 
완벽하다는 것은 필수 부분이 모두 완벽하게 수행되고 오동작 없이 작동함을 의미합니다. 
이 프로젝트에서는 모든 벤치마크를 예외 없이 통과하는 것을 의미합니다. 
필수 요구 사항을 모두 통과하지 않았다면 보너스 부분은 전혀 평가되지 않습니다.

1. The "checker" program
Program name : checker
Turn in files : *.h, *.c
Makefile : bonus
Arguments : stack a: A list of integers
External functs : read, write, malloc, free, exit, ft_printf and any equivalent YOU coded
libft authorized : Yes
Description : Execute the sorting instructions

• checker라는 프로그램을 작성하세요. 이 프로그램은 정수 목록 형식으로 포맷된 스택 a를 인수로 받습니다. 첫 번째 인수는 스택의 맨 위에 있어야 합니다 (순서에 주의하세요). 만약 인수가 주어지지 않으면 실행을 멈추고 아무것도 표시하지 않습니다.
• 그런 다음, 표준 입력에서 명령어를 기다리고 읽습니다. 각 명령어는 '\n'으로 끝납니다. 모든 명령어를 읽은 후, 프로그램은 인수로 받은 스택에 대해 명령어를 실행해야 합니다.
• 이러한 명령어를 실행한 후에도 스택 a가 실제로 정렬되어 있고 스택 b가 비어 있으면 프로그램은 표준 출력에 "OK" 다음에 '\n'을 표시해야 합니다.
• 그 밖의 경우에는 표준 출력에 "KO" 다음에 '\n'을 표시해야 합니다.
• 오류가 발생한 경우, 표준 오류에 "Error" 다음에 '\n'을 표시해야 합니다. 오류에는 예를 들어 다음과 같은 것들이 포함됩니다: 일부 인수가 정수가 아니거나, 일부 인수가 정수보다 크거나, 중복이 있는 경우, 명령어가 존재하지 않거나/또는 잘못된 형식으로 입력된 경우 등입니다.

warning
제공된 이진 파일과 정확히 동일한 동작을 재현할 필요는 없습니다. 오류를 처리하는 것은 필수지만 인수를 구문 분석하는 방법은 여러분이 결정할 수 있습니다.
보너스 부분은 필수 부분이 완벽하게 완료되었을 때만 평가됩니다. 완벽하다는 것은 필수 부분이 모두 완벽하게 수행되고 오동작 없이 작동함을 의미합니다. 이 프로젝트에서는 모든 벤치마크를 예외 없이 통과하는 것을 의미합니다. 필수 요구 사항을 모두 통과하지 않았다면 보너스 부분은 전혀 평가되지 않습니다.


